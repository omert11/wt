#!/bin/bash
# wt - Universal Git Worktree Manager
# Supports: Flutter, npm, Rust, Python/Django, Go, and generic projects

set -e

# ==========================================
# DEFAULT CONFIG (can be overridden by ~/.config/wt/config)
# ==========================================

# Folders to copy
COPY_FOLDERS=(
    ".vscode"
    ".claude"
)

# Files to copy
COPY_FILES=(
    ".env"
)

# Worktree settings
WORKTREE_DIR_PATTERN="../{project}-worktrees"

# Commands to run in new worktrees after setup
INIT_COMMANDS=()

# PR settings
PR_MERGE_METHOD="squash"
PR_DELETE_BRANCH=true
PR_AUTO_MERGE=false

# ==========================================
# Load user config (if exists)
# ==========================================
CONFIG_FILE="$HOME/.config/wt/config"
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# Load project-local config (if exists, at git repo root)
_WT_GIT_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || true)"
if [ -n "$_WT_GIT_ROOT" ] && [ -f "$_WT_GIT_ROOT/.wtconfig" ]; then
    source "$_WT_GIT_ROOT/.wtconfig"
else
    # Try main worktree (when running from a linked worktree)
    _WT_MAIN_ROOT="$(git worktree list --porcelain 2>/dev/null | head -1 | sed 's/^worktree //' || true)"
    if [ -n "$_WT_MAIN_ROOT" ] && [ -f "$_WT_MAIN_ROOT/.wtconfig" ]; then
        source "$_WT_MAIN_ROOT/.wtconfig"
    fi
fi

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Helper functions
print_success() { echo -e "${GREEN}✓${NC} $1"; }
print_error() { echo -e "${RED}✗${NC} $1"; }
print_info() { echo -e "${BLUE}→${NC} $1"; }
print_warn() { echo -e "${YELLOW}!${NC} $1"; }

# Detect project type from current directory
detect_project_type() {
    if [ -f "pubspec.yaml" ]; then
        echo "flutter"
    elif [ -f "Cargo.toml" ]; then
        echo "rust"
    elif [ -f "requirements.txt" ]; then
        echo "python"
    elif [ -f "go.mod" ]; then
        echo "go"
    elif [ -f "Gemfile" ]; then
        echo "ruby"
    elif [ -f "composer.json" ]; then
        echo "php"
    elif [ -f "package.json" ]; then
        echo "npm"
    else
        echo "generic"
    fi
}

# Get project name from current directory
get_project_name() {
    basename "$(pwd)"
}

# Setup project based on type
setup_project() {
    local project_type=$1
    local worktree_path=$2

    cd "$worktree_path"

    case "$project_type" in
        flutter)
            print_info "Flutter project detected"
            print_info "Running flutter pub get..."
            flutter pub get > /dev/null 2>&1
            print_success "Dependencies installed"

            if grep -q "build_runner" pubspec.yaml 2>/dev/null; then
                print_info "Running build_runner..."
                flutter pub run build_runner build --delete-conflicting-outputs > /dev/null 2>&1
                print_success "Code generation complete"
            fi
            ;;
        rust)
            print_info "Rust project detected"
            print_info "Running cargo fetch..."
            cargo fetch > /dev/null 2>&1
            print_success "Dependencies fetched"
            ;;
        npm)
            print_info "Node.js project detected"
            if [ -f "pnpm-lock.yaml" ]; then
                print_info "Running pnpm install..."
                pnpm install > /dev/null 2>&1
            elif [ -f "yarn.lock" ]; then
                print_info "Running yarn install..."
                yarn install > /dev/null 2>&1
            elif [ -f "bun.lockb" ]; then
                print_info "Running bun install..."
                bun install > /dev/null 2>&1
            else
                print_info "Running npm install..."
                npm install > /dev/null 2>&1
            fi
            print_success "Dependencies installed"
            ;;
        python)
            print_info "Python project detected"
            if [ -f "requirements.txt" ]; then
                if command -v uv &> /dev/null; then
                    print_info "Running uv pip install..."
                    uv venv .venv
                    source .venv/bin/activate
                    uv pip install -r requirements.txt > /dev/null 2>&1
                else
                    print_info "Running pip install..."
                    python3 -m venv .venv
                    source .venv/bin/activate
                    pip install -r requirements.txt > /dev/null 2>&1
                fi
                print_success "Dependencies installed"
            fi
            ;;
        go)
            print_info "Go project detected"
            print_info "Running go mod download..."
            go mod download > /dev/null 2>&1
            print_success "Dependencies downloaded"
            ;;
        ruby)
            print_info "Ruby project detected"
            print_info "Running bundle install..."
            bundle install > /dev/null 2>&1
            print_success "Dependencies installed"
            ;;
        php)
            print_info "PHP project detected"
            print_info "Running composer install..."
            composer install > /dev/null 2>&1
            print_success "Dependencies installed"
            ;;
        generic)
            print_info "Generic project (no specific setup)"
            ;;
    esac
}

# Copy config folders and files from main repo to worktree
copy_config_items() {
    local main_repo=$1
    local worktree_path=$2
    local copied=0

    # Copy folders
    for folder in "${COPY_FOLDERS[@]}"; do
        if [ -d "$main_repo/$folder" ]; then
            cp -r "$main_repo/$folder" "$worktree_path/"
            print_success "Copied $folder/"
            ((copied++))
        fi
    done

    # Copy files
    for file in "${COPY_FILES[@]}"; do
        if [ -f "$main_repo/$file" ]; then
            cp "$main_repo/$file" "$worktree_path/"
            print_success "Copied $file"
            ((copied++))
        fi
    done

    if [ "$copied" -eq 0 ]; then
        print_info "No config items to copy"
    fi
}

# Add worktree to VSCode workspace (if running in VSCode terminal)
add_to_vscode_workspace() {
    local worktree_path="$1"

    if [[ "$TERM_PROGRAM" == "vscode" ]]; then
        if command -v code &> /dev/null; then
            read -p "Add to VSCode workspace? [Y/n] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Nn]$ ]]; then
                code --add "$worktree_path"
                print_success "Added to VSCode workspace"
            fi
        else
            print_warn "VSCode 'code' command not found in PATH"
        fi
    fi
}

# Get worktree base directory
get_worktree_base() {
    local project_name=$(get_project_name)
    echo "${WORKTREE_DIR_PATTERN//\{project\}/$project_name}"
}

# Get main repo path
get_main_repo() {
    git rev-parse --show-toplevel
}

show_help() {
    echo -e "${CYAN}wt${NC} - Universal Git Worktree Manager"
    echo ""
    echo -e "${YELLOW}Usage:${NC}"
    echo "  wt <command> [options]"
    echo ""
    echo -e "${YELLOW}Commands:${NC}"
    echo "  new, n     [name] [base]   Create new worktree or pick existing branch"
    echo "  list, ls                   List all worktrees"
    echo "  remove, rm <name>          Remove a worktree"
    echo "  clean                      Remove all worktrees"
    echo "  path, p    <name>          Print worktree path"
    echo "  go, g      <name>          Change directory to worktree"
    echo "  claude, c  [name]          Open Claude Code in worktree"
    echo "  top                        Go to main repo directory"
    echo "  merge, m   [name]          Create PR, merge, and cleanup worktree"
    echo "  status, st                 Show status of all worktrees"
    echo "  type                       Show detected project type"
    echo "  init                       Initialize wt for this project (.wtconfig)"
    echo "  config     [show|edit]     Show or edit configuration"
    echo "  help, h                    Show this help"
    echo ""
    echo -e "${YELLOW}Supported Projects:${NC}"
    echo "  Flutter, Rust, npm/yarn/pnpm/bun, Python/Django, Go, Ruby, PHP"
    echo ""
    echo -e "${YELLOW}Examples:${NC}"
    echo "  wt init                    # Initialize wt in current project"
    echo "  wt new auth                # Create new branch 'auth' + worktree"
    echo "  wt new fix-bug main        # Create from main branch"
    echo "  wt new                     # Pick from existing branches"
    echo "  wt go auth                 # Go to auth worktree"
    echo "  wt claude auth             # Open Claude Code in auth worktree"
    echo "  wt merge auth              # PR create → merge → cleanup"
    echo "  wt config edit             # Edit global config"
    echo "  wt ls                      # List worktrees"
    echo "  wt rm auth                 # Remove auth worktree"
}

# Check that .wtconfig exists in project root
require_config() {
    local git_root
    git_root="$(git rev-parse --show-toplevel 2>/dev/null || true)"
    local config_found=false

    if [ -n "$git_root" ] && [ -f "$git_root/.wtconfig" ]; then
        config_found=true
    else
        local main_root
        main_root="$(git worktree list --porcelain 2>/dev/null | head -1 | sed 's/^worktree //' || true)"
        if [ -n "$main_root" ] && [ -f "$main_root/.wtconfig" ]; then
            config_found=true
        fi
    fi

    if [ "$config_found" = false ]; then
        print_error "No .wtconfig found. Run 'wt init' first." >&2
        exit 1
    fi
}

ensure_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_error "Not a git repository"
        exit 1
    fi
}

ensure_worktree_base() {
    local base=$(get_worktree_base)
    if [ ! -d "$base" ]; then
        mkdir -p "$base"
        print_info "Created worktree directory: $base"
    fi
}

get_default_branch() {
    git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main"
}

# Create new worktree
cmd_new() {
    ensure_git_repo
    require_config

    local name=$1
    local base=${2:-$(get_default_branch)}
    local use_existing_branch=false
    local branch_name=""
    local dir_name=""

    if [ -z "$name" ]; then
        # Interactive: pick from existing branches
        echo -e "${CYAN}Available branches:${NC}"
        echo ""

        local branches=()
        while IFS= read -r b; do
            branches+=("$b")
        done < <(git branch --format='%(refname:short)' --sort=-committerdate)

        # Add remote-only branches
        while IFS= read -r b; do
            local local_name="${b#origin/}"
            if [[ "$local_name" != "HEAD" ]] && ! printf '%s\n' "${branches[@]}" | grep -qx "$local_name" 2>/dev/null; then
                branches+=("$local_name")
            fi
        done < <(git branch -r --format='%(refname:short)' --sort=-committerdate 2>/dev/null)

        if [ ${#branches[@]} -eq 0 ]; then
            print_error "No branches found"
            exit 1
        fi

        local i
        for i in "${!branches[@]}"; do
            printf "  ${GREEN}%d)${NC} %s\n" $((i+1)) "${branches[$i]}"
        done

        echo ""
        read -p "Select branch (number): " selection

        if ! [[ "$selection" =~ ^[0-9]+$ ]] || [ "$selection" -lt 1 ] || [ "$selection" -gt ${#branches[@]} ]; then
            print_error "Invalid selection"
            exit 1
        fi

        branch_name="${branches[$((selection-1))]}"
        # Directory name: replace slashes with dashes
        dir_name="${branch_name//\//-}"
        use_existing_branch=true
    else
        branch_name="$name"
        dir_name="$name"
    fi

    ensure_worktree_base

    local worktree_base=$(get_worktree_base)
    # Convert to absolute path for reliable use after cd
    mkdir -p "$worktree_base"
    local worktree_path="$(cd "$worktree_base" && pwd)/$dir_name"
    local main_repo=$(get_main_repo)
    local project_type=$(detect_project_type)

    if [ -d "$worktree_path" ]; then
        print_error "Worktree already exists: $worktree_path"
        exit 1
    fi

    echo -e "${CYAN}Creating worktree: $dir_name${NC}"
    echo -e "Branch: ${GREEN}$branch_name${NC}"
    echo -e "Project type: ${GREEN}$project_type${NC}"
    echo ""

    cd "$main_repo"

    if [ "$use_existing_branch" = true ]; then
        # Use existing branch
        print_info "Creating worktree from existing branch $branch_name..."
        git worktree add "$worktree_path" "$branch_name"
    else
        # Create new branch
        print_info "Creating branch $branch_name from $base..."
        git worktree add -b "$branch_name" "$worktree_path" "$base" 2>/dev/null || \
        git worktree add "$worktree_path" "$branch_name"
    fi
    print_success "Worktree created"

    # Copy config folders and files
    copy_config_items "$main_repo" "$worktree_path"

    # Setup project
    setup_project "$project_type" "$worktree_path"

    # Run init commands
    if [ ${#INIT_COMMANDS[@]} -gt 0 ]; then
        print_info "Running init commands..."
        cd "$worktree_path"
        for init_cmd in "${INIT_COMMANDS[@]}"; do
            print_info "$ $init_cmd"
            eval "$init_cmd" || print_warn "Command failed: $init_cmd"
        done
    fi

    # Add to VSCode workspace if running in VSCode terminal
    add_to_vscode_workspace "$worktree_path"

    echo ""
    print_success "Worktree ready: $worktree_path"
    echo ""
    echo -e "${YELLOW}To enter worktree:${NC}"
    echo "  wt go $dir_name"
}

# Go to existing worktree (outputs cd command for shell function)
cmd_go() {
    ensure_git_repo
    require_config

    local name=$1

    if [ -z "$name" ]; then
        print_error "Name required. Usage: wt go <name>" >&2
        exit 1
    fi

    local worktree_base=$(get_worktree_base)
    local worktree_path="$worktree_base/$name"

    if [ ! -d "$worktree_path" ]; then
        print_error "Worktree not found: $name" >&2
        echo "Available worktrees:" >&2
        cmd_list >&2
        exit 1
    fi

    # Output cd command for eval by shell function
    echo "cd '$worktree_path'"
}

# Open Claude Code in worktree (outputs cd && claude command for shell function)
cmd_claude() {
    ensure_git_repo
    require_config

    local name=$1
    local worktree_base=$(get_worktree_base)
    local worktree_path

    if [ -z "$name" ]; then
        # If no name, use current directory if it's a worktree
        local current_dir=$(pwd)
        if [[ "$current_dir" == *"$worktree_base"* ]]; then
            worktree_path="$current_dir"
        else
            print_error "Name required or run from within a worktree. Usage: wt claude <name>" >&2
            exit 1
        fi
    else
        worktree_path="$worktree_base/$name"
    fi

    if [ ! -d "$worktree_path" ]; then
        print_error "Worktree not found: $name" >&2
        echo "Available worktrees:" >&2
        cmd_list >&2
        exit 1
    fi

    # Output cd && claude command for eval by shell function
    echo "cd '$worktree_path' && claude"
}

# Go to main repo (top-level directory)
cmd_top() {
    ensure_git_repo
    require_config
    local main_repo=$(get_main_repo)
    echo "cd '$main_repo'"
}

# List worktrees
cmd_list() {
    ensure_git_repo
    require_config

    echo -e "${CYAN}Git Worktrees:${NC}"
    echo ""

    local main_repo=$(get_main_repo)
    cd "$main_repo"

    git worktree list --porcelain | while read -r line; do
        if [[ $line == worktree* ]]; then
            path="${line#worktree }"
            echo -e "${BLUE}→${NC} $path"
        elif [[ $line == branch* ]]; then
            branch="${line#branch refs/heads/}"
            echo -e "  ${GREEN}$branch${NC}"
        elif [[ $line == "bare" ]]; then
            echo -e "  ${YELLOW}(bare)${NC}"
        fi
    done
}

# Remove worktree
cmd_remove() {
    ensure_git_repo
    require_config

    local name=$1

    if [ -z "$name" ]; then
        print_error "Name required. Usage: wt rm <name>"
        exit 1
    fi

    local worktree_base=$(get_worktree_base)
    local worktree_path="$worktree_base/$name"
    local main_repo=$(get_main_repo)

    if [ ! -d "$worktree_path" ]; then
        print_error "Worktree not found: $worktree_path"
        exit 1
    fi

    # Get actual branch name from worktree
    local branch_name
    branch_name=$(git -C "$worktree_path" branch --show-current 2>/dev/null || true)

    echo -e "${CYAN}Removing worktree: $name${NC}"

    cd "$main_repo"
    git worktree remove "$worktree_path" --force
    print_success "Worktree removed"

    # Optionally delete branch
    if [ -n "$branch_name" ]; then
        read -p "Delete branch $branch_name? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            git branch -D "$branch_name" 2>/dev/null && \
            print_success "Branch deleted" || \
            print_warn "Branch not found or already deleted"
        fi
    fi
}

# Clean all worktrees
cmd_clean() {
    ensure_git_repo
    require_config

    echo -e "${CYAN}Cleaning all worktrees...${NC}"

    local main_repo=$(get_main_repo)
    cd "$main_repo"

    # Get worktree paths excluding main repo
    local worktrees=()
    while read -r line; do
        if [[ $line == worktree* ]]; then
            local wt_path="${line#worktree }"
            if [ "$wt_path" != "$main_repo" ]; then
                worktrees+=("$wt_path")
            fi
        fi
    done < <(git worktree list --porcelain)

    if [ ${#worktrees[@]} -eq 0 ]; then
        print_info "No worktrees to clean"
        return
    fi

    for wt in "${worktrees[@]}"; do
        print_info "Removing: $wt"
        git worktree remove "$wt" --force 2>/dev/null || true
    done

    git worktree prune
    print_success "All worktrees cleaned"
}

# Get worktree path
cmd_path() {
    ensure_git_repo
    require_config

    local name=$1

    if [ -z "$name" ]; then
        print_error "Name required. Usage: wt path <name>" >&2
        exit 1
    fi

    local worktree_base=$(get_worktree_base)
    local worktree_path="$worktree_base/$name"

    if [ -d "$worktree_path" ]; then
        echo "$worktree_path"
    else
        print_error "Worktree not found: $name" >&2
        exit 1
    fi
}

# Status of all worktrees
cmd_status() {
    ensure_git_repo
    require_config

    echo -e "${CYAN}Worktree Status:${NC}"
    echo ""

    local main_repo=$(get_main_repo)
    cd "$main_repo"

    git worktree list --porcelain | grep "^worktree" | cut -d' ' -f2- | while read -r wt; do
        if [ -d "$wt" ]; then
            echo -e "${BLUE}$wt${NC}"
            cd "$wt"

            branch=$(git branch --show-current)
            echo -e "  Branch: ${GREEN}$branch${NC}"

            changes=$(git status --porcelain | wc -l | tr -d ' ')
            if [ "$changes" -gt 0 ]; then
                echo -e "  Changes: ${YELLOW}$changes files${NC}"
            else
                echo -e "  Changes: ${GREEN}clean${NC}"
            fi

            ahead=$(git rev-list --count @{upstream}..HEAD 2>/dev/null || echo "?")
            behind=$(git rev-list --count HEAD..@{upstream} 2>/dev/null || echo "?")
            echo -e "  Ahead/Behind: ${CYAN}↑$ahead ↓$behind${NC}"

            echo ""
        fi
    done
}

# Show project type
cmd_type() {
    ensure_git_repo
    local project_type=$(detect_project_type)
    echo -e "Project type: ${GREEN}$project_type${NC}"
}

# Config management
cmd_config() {
    local action=${1:-show}
    local config_dir="$HOME/.config/wt"
    local config_file="$config_dir/config"

    case "$action" in
        edit|e)
            # Create config dir and file if not exists
            if [ ! -f "$config_file" ]; then
                mkdir -p "$config_dir"
                # Copy defaults to config file
                cat > "$config_file" << 'EOF'
# wt configuration file

# Folders to copy from main repo to worktree
COPY_FOLDERS=(
    ".vscode"
    ".claude"
    ".idea"
)

# Files to copy from main repo to worktree
COPY_FILES=(
    ".env"
)

# Worktree directory pattern (relative to project)
WORKTREE_DIR_PATTERN="../{project}-worktrees"

# PR merge method: squash, merge, rebase
PR_MERGE_METHOD="squash"

# Delete branch after merge
PR_DELETE_BRANCH=true

# Auto-confirm merge (skip confirmation prompt)
PR_AUTO_MERGE=false
EOF
                print_success "Created config file: $config_file"
            fi
            # Open in default editor
            ${EDITOR:-nano} "$config_file"
            ;;
        show|s)
            echo -e "${CYAN}wt Configuration${NC}"
            echo ""
            echo -e "${YELLOW}Config file:${NC} $config_file"
            echo -e "${YELLOW}Exists:${NC} $([ -f "$config_file" ] && echo "yes" || echo "no (using defaults)")"
            echo ""
            echo -e "${YELLOW}Current values:${NC}"
            echo "  COPY_FOLDERS: ${COPY_FOLDERS[*]}"
            echo "  COPY_FILES: ${COPY_FILES[*]}"
            echo "  WORKTREE_DIR_PATTERN: $WORKTREE_DIR_PATTERN"
            echo "  INIT_COMMANDS: ${INIT_COMMANDS[*]:-(none)}"
            echo "  PR_MERGE_METHOD: $PR_MERGE_METHOD"
            echo "  PR_DELETE_BRANCH: $PR_DELETE_BRANCH"
            echo "  PR_AUTO_MERGE: $PR_AUTO_MERGE"
            ;;
        path)
            echo "$config_file"
            ;;
        *)
            print_error "Unknown config action: $action"
            echo "Usage: wt config [show|edit|path]"
            exit 1
            ;;
    esac
}

# Initialize project with .wtconfig
cmd_init() {
    ensure_git_repo

    local git_root
    git_root=$(get_main_repo)
    local config_path="$git_root/.wtconfig"
    local project_type=$(detect_project_type)

    # Check if .wtconfig already exists
    if [ -f "$config_path" ]; then
        print_warn ".wtconfig already exists at: $config_path"
        read -p "Overwrite? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_info "Skipped. Existing config preserved."
            return
        fi
    fi

    cat > "$config_path" << EOF
# wt project configuration
# Project type: $project_type
# Docs: https://github.com/omert11/wt

# ==========================================
# Folders to copy from main repo to worktree
# ==========================================
COPY_FOLDERS=(
    ".vscode"
    ".claude"
)

# ==========================================
# Files to copy from main repo to worktree
# ==========================================
COPY_FILES=(
    ".env"
)

# ==========================================
# Worktree Settings
# ==========================================

# Worktree directory pattern (relative to project)
# {project} is replaced with the project directory name
WORKTREE_DIR_PATTERN="../{project}-worktrees"

# ==========================================
# Commands to run after worktree creation
# ==========================================
# These commands run in the new worktree directory after project setup
# Example:
#   INIT_COMMANDS=(
#       "cp .env.example .env"
#       "make setup"
#       "docker compose up -d"
#   )
INIT_COMMANDS=()

# ==========================================
# GitHub PR Settings
# ==========================================

# Merge method: squash, merge, rebase
PR_MERGE_METHOD="squash"

# Delete branch after merge
PR_DELETE_BRANCH=true

# Auto-confirm merge (skip confirmation prompt)
PR_AUTO_MERGE=false
EOF

    print_success "Created .wtconfig at: $config_path"

    # Offer to edit
    read -p "Edit config now? [y/N] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        ${EDITOR:-nano} "$config_path"
    fi
}

# Merge worktree: create PR, merge, cleanup
cmd_merge() {
    ensure_git_repo
    require_config

    local name=$1
    local worktree_base=$(get_worktree_base)
    local worktree_path="$worktree_base/$name"
    local main_repo=$(get_main_repo)

    if [ -z "$name" ]; then
        # If no name provided, try to detect from current directory
        local current_dir=$(pwd)
        if [[ "$current_dir" == *"$worktree_base"* ]]; then
            name=$(basename "$current_dir")
            worktree_path="$current_dir"
        else
            print_error "Name required or run from within a worktree. Usage: wt merge <name>"
            exit 1
        fi
    fi

    if [ ! -d "$worktree_path" ]; then
        print_error "Worktree not found: $name"
        exit 1
    fi

    # Get actual branch name from worktree
    local branch_name
    branch_name=$(git -C "$worktree_path" branch --show-current 2>/dev/null || true)

    if [ -z "$branch_name" ]; then
        print_error "Could not determine branch name for worktree: $name"
        exit 1
    fi

    echo -e "${CYAN}Merging worktree: $name${NC}"
    echo -e "Branch: ${GREEN}$branch_name${NC}"
    echo ""

    cd "$worktree_path"

    # Check for uncommitted changes
    if [ -n "$(git status --porcelain)" ]; then
        print_error "Uncommitted changes in worktree. Commit or stash first."
        exit 1
    fi

    # Push branch if needed
    print_info "Pushing branch to remote..."
    git push -u origin "$branch_name" 2>/dev/null || git push

    # Create PR
    print_info "Creating pull request..."
    local pr_url=$(gh pr create --fill --head "$branch_name" 2>/dev/null || echo "")

    if [ -z "$pr_url" ]; then
        # PR might already exist
        pr_url=$(gh pr view --json url -q .url 2>/dev/null || echo "")
    fi

    if [ -z "$pr_url" ]; then
        print_error "Failed to create or find PR"
        exit 1
    fi

    print_success "PR: $pr_url"

    # Confirm merge (unless auto-merge enabled)
    if [ "$PR_AUTO_MERGE" != "true" ]; then
        echo ""
        read -p "Merge this PR? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_info "Merge cancelled"
            exit 0
        fi
    fi

    # Build merge command (without --delete-branch to avoid worktree conflicts)
    local merge_cmd="gh pr merge $branch_name --$PR_MERGE_METHOD"
    local delete_remote_branch="$PR_DELETE_BRANCH"

    # Return to main repo BEFORE merging (to avoid worktree conflicts)
    cd "$main_repo"
    
    # Merge PR
    print_info "Merging pull request ($PR_MERGE_METHOD)..."
    eval "$merge_cmd"

    print_success "PR merged"
    
    # Delete remote branch if requested (manual deletion to avoid worktree conflicts)
    if [ "$delete_remote_branch" = "true" ]; then
        print_info "Deleting remote branch..."
        git push origin --delete "$branch_name" 2>/dev/null && \
        print_success "Remote branch deleted" || \
        print_info "Remote branch already deleted"
    fi

    # Remove worktree
    print_info "Removing worktree..."
    git worktree remove "$worktree_path" --force
    print_success "Worktree removed"

    # Delete local branch
    git branch -D "$branch_name" 2>/dev/null && \
    print_success "Local branch deleted" || \
    print_info "Local branch already deleted"

    # Pull latest main
    local default_branch=$(get_default_branch)
    print_info "Pulling latest $default_branch..."
    git checkout "$default_branch"
    git pull

    echo ""
    print_success "Merge complete!"
}

# Main
case "${1:-help}" in
    new|n)
        cmd_new "$2" "$3"
        ;;
    go|g)
        cmd_go "$2"
        ;;
    claude|c)
        cmd_claude "$2"
        ;;
    top)
        cmd_top
        ;;
    list|ls)
        cmd_list
        ;;
    remove|rm)
        cmd_remove "$2"
        ;;
    clean)
        cmd_clean
        ;;
    path|p)
        cmd_path "$2"
        ;;
    status|st)
        cmd_status
        ;;
    type|t)
        cmd_type
        ;;
    merge|m)
        cmd_merge "$2"
        ;;
    init)
        cmd_init
        ;;
    config|cfg)
        cmd_config "$2"
        ;;
    help|h|--help|-h)
        show_help
        ;;
    *)
        print_error "Unknown command: $1"
        echo "Run 'wt help' for usage"
        exit 1
        ;;
esac
