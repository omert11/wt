#!/bin/bash
# wt - Universal Git Worktree Manager
# Supports: Flutter, npm, Rust, Python/Django, Go, and generic projects

set -e

# ==========================================
# DEFAULT CONFIG (can be overridden by ~/.config/wt/config)
# ==========================================

# Folders to copy
COPY_FOLDERS=(
    ".vscode"
    ".serena"
    ".claude"
    ".idea"
)

# Files to copy
COPY_FILES=(
    ".env"
    ".env.local"
    ".editorconfig"
)

# Worktree settings
WORKTREE_DIR_PATTERN="../{project}-worktrees"
BRANCH_PREFIX="feature/"

# PR settings
PR_MERGE_METHOD="squash"
PR_DELETE_BRANCH=true
PR_AUTO_MERGE=false

# ==========================================
# Load user config (if exists)
# ==========================================
CONFIG_FILE="$HOME/.config/wt/config"
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# Load project-local config (if exists)
if [ -f ".wtconfig" ]; then
    source ".wtconfig"
fi

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Helper functions
print_success() { echo -e "${GREEN}✓${NC} $1"; }
print_error() { echo -e "${RED}✗${NC} $1"; }
print_info() { echo -e "${BLUE}→${NC} $1"; }
print_warn() { echo -e "${YELLOW}!${NC} $1"; }

# Detect project type from current directory
detect_project_type() {
    if [ -f "pubspec.yaml" ]; then
        echo "flutter"
    elif [ -f "Cargo.toml" ]; then
        echo "rust"
    elif [ -f "package.json" ]; then
        echo "npm"
    elif [ -f "pyproject.toml" ] || [ -f "setup.py" ] || [ -f "requirements.txt" ]; then
        echo "python"
    elif [ -f "go.mod" ]; then
        echo "go"
    elif [ -f "Gemfile" ]; then
        echo "ruby"
    elif [ -f "composer.json" ]; then
        echo "php"
    else
        echo "generic"
    fi
}

# Get project name from current directory
get_project_name() {
    basename "$(pwd)"
}

# Setup project based on type
setup_project() {
    local project_type=$1
    local worktree_path=$2

    cd "$worktree_path"

    case "$project_type" in
        flutter)
            print_info "Flutter project detected"
            print_info "Running flutter pub get..."
            flutter pub get > /dev/null 2>&1
            print_success "Dependencies installed"

            if grep -q "build_runner" pubspec.yaml 2>/dev/null; then
                print_info "Running build_runner..."
                flutter pub run build_runner build --delete-conflicting-outputs > /dev/null 2>&1
                print_success "Code generation complete"
            fi
            ;;
        rust)
            print_info "Rust project detected"
            print_info "Running cargo fetch..."
            cargo fetch > /dev/null 2>&1
            print_success "Dependencies fetched"
            ;;
        npm)
            print_info "Node.js project detected"
            if [ -f "pnpm-lock.yaml" ]; then
                print_info "Running pnpm install..."
                pnpm install > /dev/null 2>&1
            elif [ -f "yarn.lock" ]; then
                print_info "Running yarn install..."
                yarn install > /dev/null 2>&1
            elif [ -f "bun.lockb" ]; then
                print_info "Running bun install..."
                bun install > /dev/null 2>&1
            else
                print_info "Running npm install..."
                npm install > /dev/null 2>&1
            fi
            print_success "Dependencies installed"
            ;;
        python)
            print_info "Python project detected"
            if [ -f "pyproject.toml" ]; then
                if grep -q "poetry" pyproject.toml 2>/dev/null; then
                    print_info "Running poetry install..."
                    poetry install > /dev/null 2>&1
                elif grep -q "uv" pyproject.toml 2>/dev/null || [ -f "uv.lock" ]; then
                    print_info "Running uv sync..."
                    uv sync > /dev/null 2>&1
                else
                    print_info "Running pip install..."
                    pip install -e . > /dev/null 2>&1
                fi
            elif [ -f "requirements.txt" ]; then
                print_info "Running pip install..."
                pip install -r requirements.txt > /dev/null 2>&1
            fi
            print_success "Dependencies installed"
            ;;
        go)
            print_info "Go project detected"
            print_info "Running go mod download..."
            go mod download > /dev/null 2>&1
            print_success "Dependencies downloaded"
            ;;
        ruby)
            print_info "Ruby project detected"
            print_info "Running bundle install..."
            bundle install > /dev/null 2>&1
            print_success "Dependencies installed"
            ;;
        php)
            print_info "PHP project detected"
            print_info "Running composer install..."
            composer install > /dev/null 2>&1
            print_success "Dependencies installed"
            ;;
        generic)
            print_info "Generic project (no specific setup)"
            ;;
    esac
}

# Copy config folders and files from main repo to worktree
copy_config_items() {
    local main_repo=$1
    local worktree_path=$2
    local copied=0

    # Copy folders
    for folder in "${COPY_FOLDERS[@]}"; do
        if [ -d "$main_repo/$folder" ]; then
            cp -r "$main_repo/$folder" "$worktree_path/"
            print_success "Copied $folder/"
            ((copied++))
        fi
    done

    # Copy files
    for file in "${COPY_FILES[@]}"; do
        if [ -f "$main_repo/$file" ]; then
            cp "$main_repo/$file" "$worktree_path/"
            print_success "Copied $file"
            ((copied++))
        fi
    done

    if [ "$copied" -eq 0 ]; then
        print_info "No config items to copy"
    fi
}

# Get worktree base directory
get_worktree_base() {
    local project_name=$(get_project_name)
    echo "${WORKTREE_DIR_PATTERN//\{project\}/$project_name}"
}

# Get main repo path
get_main_repo() {
    git rev-parse --show-toplevel
}

show_help() {
    echo -e "${CYAN}wt${NC} - Universal Git Worktree Manager"
    echo ""
    echo -e "${YELLOW}Usage:${NC}"
    echo "  wt <command> [options]"
    echo ""
    echo -e "${YELLOW}Commands:${NC}"
    echo "  new, n     <name> [base]   Create new worktree (default base: main/master)"
    echo "  list, ls                   List all worktrees"
    echo "  remove, rm <name>          Remove a worktree"
    echo "  clean                      Remove all worktrees"
    echo "  path, p    <name>          Print worktree path"
    echo "  go, g      <name>          Change directory to worktree"
    echo "  merge, m   [name]          Create PR, merge, and cleanup worktree"
    echo "  status, st                 Show status of all worktrees"
    echo "  type                       Show detected project type"
    echo "  config     [show|edit]     Show or edit configuration"
    echo "  help, h                    Show this help"
    echo ""
    echo -e "${YELLOW}Supported Projects:${NC}"
    echo "  Flutter, Rust, npm/yarn/pnpm/bun, Python/Django, Go, Ruby, PHP"
    echo ""
    echo -e "${YELLOW}Examples:${NC}"
    echo "  wt new auth                # Create feature/auth worktree + setup"
    echo "  wt new fix-bug main        # Create from main branch"
    echo "  wt go auth                 # Go to auth worktree"
    echo "  wt merge auth              # PR create → merge → cleanup"
    echo "  wt config edit             # Edit global config"
    echo "  wt ls                      # List worktrees"
    echo "  wt rm auth                 # Remove auth worktree"
}

ensure_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_error "Not a git repository"
        exit 1
    fi
}

ensure_worktree_base() {
    local base=$(get_worktree_base)
    if [ ! -d "$base" ]; then
        mkdir -p "$base"
        print_info "Created worktree directory: $base"
    fi
}

get_default_branch() {
    git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main"
}

# Create new worktree
cmd_new() {
    ensure_git_repo

    local name=$1
    local base=${2:-$(get_default_branch)}

    if [ -z "$name" ]; then
        print_error "Name required. Usage: wt new <name> [base-branch]"
        exit 1
    fi

    ensure_worktree_base

    local worktree_base=$(get_worktree_base)
    local worktree_path="$worktree_base/$name"
    local branch_name="${BRANCH_PREFIX}$name"
    local main_repo=$(get_main_repo)
    local project_type=$(detect_project_type)

    if [ -d "$worktree_path" ]; then
        print_error "Worktree already exists: $worktree_path"
        exit 1
    fi

    echo -e "${CYAN}Creating worktree: $name${NC}"
    echo -e "Project type: ${GREEN}$project_type${NC}"
    echo ""

    # Create worktree
    print_info "Creating branch $branch_name from $base..."
    cd "$main_repo"
    git worktree add -b "$branch_name" "$worktree_path" "$base" 2>/dev/null || \
    git worktree add "$worktree_path" "$branch_name"
    print_success "Worktree created"

    # Copy config folders and files
    copy_config_items "$main_repo" "$worktree_path"

    # Setup project
    setup_project "$project_type" "$worktree_path"

    echo ""
    print_success "Worktree ready: $worktree_path"
    echo ""
    echo -e "${YELLOW}To enter worktree:${NC}"
    echo "  wt go $name"
}

# Go to existing worktree (outputs cd command for shell function)
cmd_go() {
    ensure_git_repo

    local name=$1

    if [ -z "$name" ]; then
        print_error "Name required. Usage: wt go <name>" >&2
        exit 1
    fi

    local worktree_base=$(get_worktree_base)
    local worktree_path="$worktree_base/$name"

    if [ ! -d "$worktree_path" ]; then
        print_error "Worktree not found: $name" >&2
        echo "Available worktrees:" >&2
        cmd_list >&2
        exit 1
    fi

    # Output cd command for eval by shell function
    echo "cd '$worktree_path'"
}

# List worktrees
cmd_list() {
    ensure_git_repo

    echo -e "${CYAN}Git Worktrees:${NC}"
    echo ""

    local main_repo=$(get_main_repo)
    cd "$main_repo"

    git worktree list --porcelain | while read -r line; do
        if [[ $line == worktree* ]]; then
            path="${line#worktree }"
            echo -e "${BLUE}→${NC} $path"
        elif [[ $line == branch* ]]; then
            branch="${line#branch refs/heads/}"
            echo -e "  ${GREEN}$branch${NC}"
        elif [[ $line == "bare" ]]; then
            echo -e "  ${YELLOW}(bare)${NC}"
        fi
    done
}

# Remove worktree
cmd_remove() {
    ensure_git_repo

    local name=$1

    if [ -z "$name" ]; then
        print_error "Name required. Usage: wt rm <name>"
        exit 1
    fi

    local worktree_base=$(get_worktree_base)
    local worktree_path="$worktree_base/$name"
    local branch_name="${BRANCH_PREFIX}$name"
    local main_repo=$(get_main_repo)

    if [ ! -d "$worktree_path" ]; then
        print_error "Worktree not found: $worktree_path"
        exit 1
    fi

    echo -e "${CYAN}Removing worktree: $name${NC}"

    cd "$main_repo"
    git worktree remove "$worktree_path" --force
    print_success "Worktree removed"

    # Optionally delete branch
    read -p "Delete branch $branch_name? [y/N] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        git branch -D "$branch_name" 2>/dev/null && \
        print_success "Branch deleted" || \
        print_warn "Branch not found or already deleted"
    fi
}

# Clean all worktrees
cmd_clean() {
    ensure_git_repo

    echo -e "${CYAN}Cleaning all worktrees...${NC}"

    local main_repo=$(get_main_repo)
    cd "$main_repo"

    # Get worktree paths excluding main repo
    local worktrees=()
    while read -r line; do
        if [[ $line == worktree* ]]; then
            local wt_path="${line#worktree }"
            if [ "$wt_path" != "$main_repo" ]; then
                worktrees+=("$wt_path")
            fi
        fi
    done < <(git worktree list --porcelain)

    if [ ${#worktrees[@]} -eq 0 ]; then
        print_info "No worktrees to clean"
        return
    fi

    for wt in "${worktrees[@]}"; do
        print_info "Removing: $wt"
        git worktree remove "$wt" --force 2>/dev/null || true
    done

    git worktree prune
    print_success "All worktrees cleaned"
}

# Get worktree path
cmd_path() {
    ensure_git_repo

    local name=$1

    if [ -z "$name" ]; then
        print_error "Name required. Usage: wt path <name>" >&2
        exit 1
    fi

    local worktree_base=$(get_worktree_base)
    local worktree_path="$worktree_base/$name"

    if [ -d "$worktree_path" ]; then
        echo "$worktree_path"
    else
        print_error "Worktree not found: $name" >&2
        exit 1
    fi
}

# Status of all worktrees
cmd_status() {
    ensure_git_repo

    echo -e "${CYAN}Worktree Status:${NC}"
    echo ""

    local main_repo=$(get_main_repo)
    cd "$main_repo"

    git worktree list --porcelain | grep "^worktree" | cut -d' ' -f2- | while read -r wt; do
        if [ -d "$wt" ]; then
            echo -e "${BLUE}$wt${NC}"
            cd "$wt"

            branch=$(git branch --show-current)
            echo -e "  Branch: ${GREEN}$branch${NC}"

            changes=$(git status --porcelain | wc -l | tr -d ' ')
            if [ "$changes" -gt 0 ]; then
                echo -e "  Changes: ${YELLOW}$changes files${NC}"
            else
                echo -e "  Changes: ${GREEN}clean${NC}"
            fi

            ahead=$(git rev-list --count @{upstream}..HEAD 2>/dev/null || echo "?")
            behind=$(git rev-list --count HEAD..@{upstream} 2>/dev/null || echo "?")
            echo -e "  Ahead/Behind: ${CYAN}↑$ahead ↓$behind${NC}"

            echo ""
        fi
    done
}

# Show project type
cmd_type() {
    ensure_git_repo
    local project_type=$(detect_project_type)
    echo -e "Project type: ${GREEN}$project_type${NC}"
}

# Config management
cmd_config() {
    local action=${1:-show}
    local config_dir="$HOME/.config/wt"
    local config_file="$config_dir/config"

    case "$action" in
        edit|e)
            # Create config dir and file if not exists
            if [ ! -f "$config_file" ]; then
                mkdir -p "$config_dir"
                # Copy defaults to config file
                cat > "$config_file" << 'EOF'
# wt configuration file

# Folders to copy from main repo to worktree
COPY_FOLDERS=(
    ".vscode"
    ".serena"
    ".claude"
    ".idea"
)

# Files to copy from main repo to worktree
COPY_FILES=(
    ".env"
    ".env.local"
    ".editorconfig"
)

# Worktree directory pattern (relative to project)
WORKTREE_DIR_PATTERN="../{project}-worktrees"

# Branch prefix for new worktrees
BRANCH_PREFIX="feature/"

# PR merge method: squash, merge, rebase
PR_MERGE_METHOD="squash"

# Delete branch after merge
PR_DELETE_BRANCH=true

# Auto-confirm merge (skip confirmation prompt)
PR_AUTO_MERGE=false
EOF
                print_success "Created config file: $config_file"
            fi
            # Open in default editor
            ${EDITOR:-nano} "$config_file"
            ;;
        show|s)
            echo -e "${CYAN}wt Configuration${NC}"
            echo ""
            echo -e "${YELLOW}Config file:${NC} $config_file"
            echo -e "${YELLOW}Exists:${NC} $([ -f "$config_file" ] && echo "yes" || echo "no (using defaults)")"
            echo ""
            echo -e "${YELLOW}Current values:${NC}"
            echo "  COPY_FOLDERS: ${COPY_FOLDERS[*]}"
            echo "  COPY_FILES: ${COPY_FILES[*]}"
            echo "  WORKTREE_DIR_PATTERN: $WORKTREE_DIR_PATTERN"
            echo "  BRANCH_PREFIX: $BRANCH_PREFIX"
            echo "  PR_MERGE_METHOD: $PR_MERGE_METHOD"
            echo "  PR_DELETE_BRANCH: $PR_DELETE_BRANCH"
            echo "  PR_AUTO_MERGE: $PR_AUTO_MERGE"
            ;;
        path)
            echo "$config_file"
            ;;
        *)
            print_error "Unknown config action: $action"
            echo "Usage: wt config [show|edit|path]"
            exit 1
            ;;
    esac
}

# Merge worktree: create PR, merge, cleanup
cmd_merge() {
    ensure_git_repo

    local name=$1
    local worktree_base=$(get_worktree_base)
    local worktree_path="$worktree_base/$name"
    local main_repo=$(get_main_repo)
    local branch_name="${BRANCH_PREFIX}$name"

    if [ -z "$name" ]; then
        # If no name provided, try to detect from current directory
        local current_dir=$(pwd)
        if [[ "$current_dir" == *"$worktree_base"* ]]; then
            name=$(basename "$current_dir")
            worktree_path="$current_dir"
            branch_name="${BRANCH_PREFIX}$name"
        else
            print_error "Name required or run from within a worktree. Usage: wt merge <name>"
            exit 1
        fi
    fi

    if [ ! -d "$worktree_path" ]; then
        print_error "Worktree not found: $name"
        exit 1
    fi

    echo -e "${CYAN}Merging worktree: $name${NC}"
    echo ""

    cd "$worktree_path"

    # Check for uncommitted changes
    if [ -n "$(git status --porcelain)" ]; then
        print_error "Uncommitted changes in worktree. Commit or stash first."
        exit 1
    fi

    # Push branch if needed
    print_info "Pushing branch to remote..."
    git push -u origin "$branch_name" 2>/dev/null || git push

    # Create PR
    print_info "Creating pull request..."
    local pr_url=$(gh pr create --fill --head "$branch_name" 2>/dev/null || echo "")

    if [ -z "$pr_url" ]; then
        # PR might already exist
        pr_url=$(gh pr view --json url -q .url 2>/dev/null || echo "")
    fi

    if [ -z "$pr_url" ]; then
        print_error "Failed to create or find PR"
        exit 1
    fi

    print_success "PR: $pr_url"

    # Confirm merge (unless auto-merge enabled)
    if [ "$PR_AUTO_MERGE" != "true" ]; then
        echo ""
        read -p "Merge this PR? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_info "Merge cancelled"
            exit 0
        fi
    fi

    # Build merge command (without --delete-branch to avoid worktree conflicts)
    local merge_cmd="gh pr merge $branch_name --$PR_MERGE_METHOD"
    local delete_remote_branch="$PR_DELETE_BRANCH"

    # Return to main repo BEFORE merging (to avoid worktree conflicts)
    cd "$main_repo"
    
    # Merge PR
    print_info "Merging pull request ($PR_MERGE_METHOD)..."
    eval "$merge_cmd"

    print_success "PR merged"
    
    # Delete remote branch if requested (manual deletion to avoid worktree conflicts)
    if [ "$delete_remote_branch" = "true" ]; then
        print_info "Deleting remote branch..."
        git push origin --delete "$branch_name" 2>/dev/null && \
        print_success "Remote branch deleted" || \
        print_info "Remote branch already deleted"
    fi

    # Remove worktree
    print_info "Removing worktree..."
    git worktree remove "$worktree_path" --force
    print_success "Worktree removed"

    # Delete local branch
    git branch -D "$branch_name" 2>/dev/null && \
    print_success "Local branch deleted" || \
    print_info "Local branch already deleted"

    # Pull latest main
    local default_branch=$(get_default_branch)
    print_info "Pulling latest $default_branch..."
    git checkout "$default_branch"
    git pull

    echo ""
    print_success "Merge complete!"
}

# Main
case "${1:-help}" in
    new|n)
        cmd_new "$2" "$3"
        ;;
    go|g)
        cmd_go "$2"
        ;;
    list|ls)
        cmd_list
        ;;
    remove|rm)
        cmd_remove "$2"
        ;;
    clean)
        cmd_clean
        ;;
    path|p)
        cmd_path "$2"
        ;;
    status|st)
        cmd_status
        ;;
    type|t)
        cmd_type
        ;;
    merge|m)
        cmd_merge "$2"
        ;;
    config|cfg)
        cmd_config "$2"
        ;;
    help|h|--help|-h)
        show_help
        ;;
    *)
        print_error "Unknown command: $1"
        echo "Run 'wt help' for usage"
        exit 1
        ;;
esac
